//5路花盆自动浇水系统：MM明媚
//硬件：1.00,盆1.2.3.4：GPIO16.3.5.4,水位捡测：GPIO15,阀门/电机1.2.3.4:0.1.14.12，18B20：GPIO2
//硬件：1.01,盆1.2.3.4：GPIO16.3.5.4,水位捡测：GPIO15,阀门/电机1.2.3.4:0.1.14.12，18B20：GPIO2,ADC温度检测：GPIO13
//硬件：1.02，量产版，盆1.2.3.4：GPIO16.3.5.4,阀门/电机1.2.3.4:0.1.14.12，ADC温度检测：GPIO13
//1.00:适配硬件1.02,1.01（不含18B20）。每间隔1分钟读取一次4路湿度传感器和温度数据，并根据数据决定是否需要浇水。浇水期间每隔200毫秒读取一次数据，达到阀值后停止浇水。读数小于100判断为传感器未接。浇水1分钟没有湿度变化判断为停水或电磁阀未接。浇水完毕后，或者检测到电池阀故障5分钟后从新测试浇水。


#include <ESP8266WiFi.h>
#include <ESP8266WiFiMulti.h>
#include <WiFiUdp.h>
#include <TimeLib.h>
#include <ArduinoOTA.h>
#include <ESP8266mDNS.h>
#include <Arduino.h>
#include <EEPROM.h>
#include <ESP8266HTTPClient.h>
#include <ESP8266httpUpdate.h>
#include <PubSubClient.h>
#include <OneWire.h>
#include <DallasTemperature.h>

ESP8266WiFiMulti wifiMulti;
WiFiClient espClient;
PubSubClient client(espClient);
HTTPClient http;
unsigned long lastMsg = 0;
#define MSG_BUFFER_SIZE  (50)
char msg[MSG_BUFFER_SIZE];



String yjbb = "00C01";//硬件版本号
String gjbb = "100";//固件版本号
//IRGreeAC ac(15);//红外发射二极管接在GPIO15上
ADC_MODE(ADC_TOUT);//ADC读取外部电压，量程1000mV，对应值为0-1023,用于测定湿度,湿度越高数值越小
OneWire oneWire(2);//18B20接在GPIO2上
DallasTemperature sensors(&oneWire);


static const char ntpServerName[] = "ntp6.aliyun.com";//授时服务器设置，阿里云NTP6授时服务器，服务器地址在杭州，速度较快
const int timeZone = 8;//设置时区为东8区
WiFiUDP Udp;
unsigned int localPort = 8888;  // local port to listen for UDP packets
time_t getNtpTime();
int  hou = 0, Asdl; // 定义程序中需要用到的整数变量
float wd;
String subtopiconline,subtopicdownline, subtopicOTA, subtopic, subtopic1, subtopicupdate, pubtopic, mqttid, mqttname, mqttpas = String ( ESP.getFlashChipId(), HEX),myip,mycity,msgwatercontent,lastmsgwatercontent; //MQTT专用参数
const char* pubtopic1; 
const char* subtopic2;
unsigned long currentMillis = 0,lastDebounceTime = 0,Updatetime = 0,lasttimeupdate = 0, lastfailedMQTTtime = 0, MQTTwaitingtime = 0, lastreadtime=0, lastwificonnecttime=0, mi=0, lasttestwatertime = 0, waterstarttime= 0, lastbadhptesttime=0; //定义程序中需要用到的无符号长整形变量
unsigned char lastwd=0, lasthou=6,lastmi=0,lastsec=0, pu=0, ota = 0, j=0, hp=15, hpl, waitingtime=5, w=2, badhp3 =0, badhp4 =0, badhp5 =0, badhp16 =0;


void setup(){
  ESP.wdtEnable(90000);//设置喂狗时间为90秒
  pinMode(16, OUTPUT); //设置GPIO1为输出（检测电源控制：花盆1）
  pinMode(3, OUTPUT); //设置GPIO3为输出（检测电源控制：花盆2）
  pinMode(5, OUTPUT); //设置GPIO5为输出（检测电源控制：花盆3）
  pinMode(4, OUTPUT); //设置GPIO4为输出（检测电源控制：花盆4）
  pinMode(15, OUTPUT); //设置GPIO2为输出（检测电源控制：水位检测）
  pinMode(0, OUTPUT); //设置GPIO0为输出（电磁阀电源控制：阀门1）
  pinMode(1, OUTPUT); //设置GPIO16为输出（电磁阀电源控制：阀门2）
  pinMode(14, OUTPUT); //设置GPIO14为输出（电磁阀电源控制：阀门3）
  pinMode(12, OUTPUT); //设置GPIO12为输出（电磁阀电源控制：阀门4）
  pinMode(13, INPUT); //设置GPIO13为ADC温度检测切换（高电位读取温度）
  digitalWrite(16, 0); //设置GPIO1（检测电源控制：花盆1 关闭）
  digitalWrite(3, 0); //设置GPIO3（检测电源控制：花盆2 关闭）
  digitalWrite(5, 0); //设置GPIO5（检测电源控制：花盆3 关闭）
  digitalWrite(4, 0); //设置GPIO4（检测电源控制：花盆4 关闭）
  digitalWrite(15, 0); //设置GPIO2（检测电源控制：水位检测 关闭）
  digitalWrite(0, 0); //设置GPIO0（电磁阀电源控制：阀门1 关闭）
  digitalWrite(1, 0); //设置GPIO1（电磁阀电源控制：阀门2 关闭）
  digitalWrite(14, 0); //设置GPIO14（电磁阀电源控制：阀门3 关闭）
  digitalWrite(12, 0); //设置GPIO12（电磁阀电源控制：阀门4 关闭）
  EEPROM.begin(256);//设置EEPROM大小为256字节

  WiFi.mode(WIFI_STA);
  wifiMulti.addAP("sunnygu", "nm19870424");
  wifiMulti.addAP("Jiang", "jiangjiajing");
  while (wifiMulti.run() != WL_CONNECTED) {
    delay(500);
    //Serial.println("沁心居-明媚 正在连接wifi，请稍候...");
  }
//初始化MQTT推送/订阅主题
  String chipid = String(ESP.getChipId(), HEX);
  String mqttnamemac;
  mqttid = "8266-5087-" + chipid;
  mqttnamemac = String(WiFi.macAddress());
  for (int i = 0; i < 18; i++) {
    if (mqttnamemac.charAt(i) == ':') {
      //跳过冒号
    } else {
      mqttname += mqttnamemac.charAt(i);
    }
  }
  subtopiconline = "8266/13656665087/online";
  subtopicdownline ="8266/13656665087/downline";
  subtopic = "8266/13656665087/#";
  subtopic1 = "8266/13656665087/"  + chipid;
  subtopicupdate = "8266/13656665087/"  + chipid + "/update";
  subtopicOTA = "8266/13656665087/"  + chipid + "/OTA";
  pubtopic = "13656665087/"  + chipid;
  subtopic2 = subtopic.c_str();
  pubtopic1 = pubtopic.c_str();
  
//18B20初始化
  sensors.begin(); 
  
//MQTT基本设定
  client.setServer("broker.qinxinju.com", 1880);
  client.setCallback(callback);
  client.setKeepAlive(60);

//NTP时间同步设置
  Udp.begin(localPort);
  setSyncProvider(getNtpTime);
  setSyncInterval(21600);//设置同步时间间隔6H，即21600s
//启动OTA升级程序
  String espname;
  espname = "QXJMM-" + chipid;
  ArduinoOTA.setHostname(espname.c_str());
  ArduinoOTA.onStart([]() {
    String type;
    if (ArduinoOTA.getCommand() == U_FLASH) {
      type = "sketch";
    } else { // U_FS
      type = "filesystem";
    }
  });
  ArduinoOTA.onEnd([]() {
    
  });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    
  });
  ArduinoOTA.onError([](ota_error_t error) {
    
    if (error == OTA_AUTH_ERROR) {
      
    } else if (error == OTA_BEGIN_ERROR) {
      
    } else if (error == OTA_CONNECT_ERROR) {
      
    } else if (error == OTA_RECEIVE_ERROR) {
      
    } else if (error == OTA_END_ERROR) {
      
    }
  });
  ArduinoOTA.begin();
  wifi_set_sleep_type(MODEM_SLEEP_T);//连上wifi后，空闲时自动进入ModemSleep模式，达到省电的效果
  //wifi_set_sleep_type(LIGHT_SLEEP_T);//连上wifi后，空闲时自动进入LightSleep模式，达到省电的效果。适合不需要接收红外信号、不需要PWM输出的场景。
}



void  testwifi(){
  if (WiFi.waitForConnectResult() == WL_CONNECTED){
    if(MQTTwaitingtime > 60000 && currentMillis - lastwificonnecttime > 60000){
      MQTTwaitingtime = 5000;
    }
    lastwificonnecttime = millis();
    if (currentMillis - lasttimeupdate > 21600000 || lasttimeupdate == 0) {//24小时：86400s，6小时21600s,1小时3600s，半小时1800s
      if (timeStatus() == timeSet) {
        lasthou = hour(); 
        lastmi= minute();
        lastsec=second();
        lasttimeupdate = millis();
      }else {
        setSyncProvider(getNtpTime);
      }
    }
  }else {
    
  }
}

void loop(){
  currentMillis = millis(); //将millis()转化为unsigned long类型，防止millis()溢出导致的各种错误
  if(currentMillis- lasttestwatertime > waitingtime){
    if (currentMillis - lastDebounceTime > 59000){ //每60秒喂狗、检查WIFI连接状态。每24小时同步一次时间
      ESP.wdtFeed();
      lastDebounceTime = millis(); //喂狗时间更新
      testwifi();
      if(myip == ""){
        getmyip();
        reconnect();
        //getmyaddress();根据IP确定城市（区县）
        pubmassage();
      }
    }else{
      testwatercontent();//检测花盆湿度
      lasttestwatertime = millis();
    }
  }
  currentMillis = millis(); //将millis()转化为unsigned long类型，防止millis()溢出导致的各种错误
  if(currentMillis-Updatetime> 980){//1000ms刷新一次时间
    //TimeUpdate();
  }
  if (!client.connected()) {
      reconnect();
  }else{
    client.loop();
  }
  if (ota == 1) {
    ArduinoOTA.handle();//启动OTA升级
  }  
  ArduinoOTA.handle();//启动OTA升级
/*  if(w == 0){
    delay(1000);//用于light sleep，不可省略
  }else{
    delay(1);//用于modern sleep，不可省略
  }*/
  delay(1);//用于modern sleep，不可省略
}


void getmyip(){
  if (http.begin(espClient, "http://ipinfo.io/ip")) {  // HTTP
    Serial.print("[HTTP] GET...\n");
    // start connection and send HTTP header
    int httpCode = http.GET();

    // httpCode will be negative on error
    if (httpCode > 0) {
      // HTTP header has been send and Server response header has been handled
      Serial.printf("[HTTP] GET... code: %d\n", httpCode);

      // file found at server
      if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
        myip = http.getString();
        Serial.println(myip);
        
      }
    } else {
      Serial.printf("[HTTP] GET... failed, error: %s\n", http.errorToString(httpCode).c_str());
    }

    http.end();
  } else {
    Serial.printf("[HTTP} Unable to connect\n");
  }
}

/*-------- NTP code ----------*/

const int NTP_PACKET_SIZE = 48; // NTP time is in the first 48 bytes of message
byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming & outgoing packets

time_t getNtpTime()
{
  IPAddress ntpServerIP; // NTP server's ip address
  while (Udp.parsePacket() > 0) ; // discard any previously received packets
  Serial.println("Transmit NTP Request");
  // get a random server from the pool
  WiFi.hostByName(ntpServerName, ntpServerIP);
  Serial.print(ntpServerName);
  Serial.print(": ");
  Serial.println(ntpServerIP);
  sendNTPpacket(ntpServerIP);
  uint32_t beginWait = millis();
  while (millis() - beginWait < 1500) {
    int size = Udp.parsePacket();
    if (size >= NTP_PACKET_SIZE) {
      Serial.println("Receive NTP Response");
      Udp.read(packetBuffer, NTP_PACKET_SIZE);  // read packet into the buffer
      unsigned long secsSince1900;
      // convert four bytes starting at location 40 to a long integer
      secsSince1900 =  (unsigned long)packetBuffer[40] << 24;
      secsSince1900 |= (unsigned long)packetBuffer[41] << 16;
      secsSince1900 |= (unsigned long)packetBuffer[42] << 8;
      secsSince1900 |= (unsigned long)packetBuffer[43];
      return secsSince1900 - 2208988800UL + timeZone * SECS_PER_HOUR;
    }
  }
  Serial.println("No NTP Response :-(");
  return 0; // return 0 if unable to get the time
}

// send an NTP request to the time server at the given address
void sendNTPpacket(IPAddress &address)
{
  // set all bytes in the buffer to 0
  memset(packetBuffer, 0, NTP_PACKET_SIZE);
  // Initialize values needed to form NTP request
  // (see URL above for details on the packets)
  packetBuffer[0] = 0b11100011;   // LI, Version, Mode
  packetBuffer[1] = 0;     // Stratum, or type of clock
  packetBuffer[2] = 6;     // Polling Interval
  packetBuffer[3] = 0xEC;  // Peer Clock Precision
  // 8 bytes of zero for Root Delay & Root Dispersion
  packetBuffer[12] = 49;
  packetBuffer[13] = 0x4E;
  packetBuffer[14] = 49;
  packetBuffer[15] = 52;
  // all NTP fields have been given values, now
  // you can send a packet requesting a timestamp:
  Udp.beginPacket(address, 123); //NTP requests are to port 123
  Udp.write(packetBuffer, NTP_PACKET_SIZE);
  Udp.endPacket();
}

void update_started() {
  Serial.println("CALLBACK:  HTTP update process started");
}

void update_finished() {
  Serial.println("CALLBACK:  HTTP update process finished");
}

void update_progress(int cur, int total) {
  Serial.printf("CALLBACK:  HTTP update process at %d of %d bytes...\n", cur, total);
}

void update_error(int err) {
  Serial.printf("CALLBACK:  HTTP update fatal error code %d\n", err);
}


void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("接收到消息[");
  Serial.print(topic);
  Serial.print("] ");
  String submsg;
  for (int i = 0; i < length; i++) {
    submsg += (char)payload[i];
  }
  Serial.println(submsg.c_str());
  
  String topic1=String(topic);
  if (topic1 == subtopiconline) {//上线消息，开启状态发送，并更改订阅为本机专用订阅
    subtopic2 = subtopic.c_str();
    client.unsubscribe(subtopic2);
    subtopic2 = subtopiconline.c_str();
    client.subscribe(subtopic2, 1);
    subtopic2 = subtopic1.c_str();
    client.subscribe(subtopic2, 1);
    subtopic2 = subtopicdownline.c_str();
    client.subscribe(subtopic2, 1);
    pu = 1;
    pubmassage();
  }else if(topic1 == subtopicdownline){//下线消息，关闭状态发送，并更改订阅为通用订阅.是否要发送一条假“遗嘱消息”呢？
    if(pu == 1){
      pu = 0;
      subtopic2 = subtopic1.c_str();
      client.unsubscribe (subtopic2);
      subtopic2 = subtopiconline.c_str();
      client.unsubscribe(subtopic2);
      subtopic2 = subtopicdownline.c_str();
      client.unsubscribe(subtopic2);
      subtopic2 = subtopic.c_str();
      client.subscribe(subtopic2, 1);
    }
  } else if (topic1 == subtopicOTA) {
    String submsgOTA;
    submsgOTA += (char)payload[0];
    if (submsgOTA == "y") {
      Serial.println("接收到远程打开本地OTA命令");
      ota = 1;
    } else {
      digitalWrite(BUILTIN_LED, HIGH);  // Turn the LED off by making the voltage HIGH
      ota = 0;
    }
  } else if (topic1 == subtopicupdate) { //接收到本机update消息后，升级固件
    Serial.println("Update!");
    // Add optional callback notifiers
    String submsgupdate;
    for (int i = 0; i < length; i++) {
      submsgupdate += (char)payload[i];
    }
    const char* updateurl = submsgupdate.c_str();
    ESPhttpUpdate.onStart(update_started);
    ESPhttpUpdate.onEnd(update_finished);
    ESPhttpUpdate.onProgress(update_progress);
    ESPhttpUpdate.onError(update_error);
    t_httpUpdate_return ret = ESPhttpUpdate.update(espClient, updateurl);
    switch (ret) {
      case HTTP_UPDATE_FAILED:
        Serial.printf("HTTP_UPDATE_FAILD Error (%d): %s\n", ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str());
        break;

      case HTTP_UPDATE_NO_UPDATES:
        Serial.println("HTTP_UPDATE_NO_UPDATES");
        break;

      case HTTP_UPDATE_OK:
        Serial.println("HTTP_UPDATE_OK");
        break;
    }
  }else if (topic1 == subtopic1) {//接收到本机专用订阅消息后，做出相应遥控动作
    Serial.println("Topic is right!");
    int subMSG1, subMSG2;
    String submsg0, submsg1, submsg2;
    submsg0 += (char)payload[0];
    if (submsg0 == "0") {
      readtemhum();
      Serial.println("接收到远程状态查询命令，状态已发送");
    } else if (submsg0 == "8") {
      ESP.restart();
    } else if (submsg0 == "9") {
//      WiFiManager wifiManager;
//      wifiManager.resetSettings();
      ESP.reset();
    } else if (submsg0 == "A") {
      Serial.println("接收到远程解锁命令(解锁程序未设定)");
    }else if (submsg0 == "T") { //接收到温度校准指令
      Serial.println("接收到远程温度校准指令，正在执行");
      String msg;
      if (length != (3)) {
        Serial.println("指令错误!");
        goto callbackend;//跳到callback的最后循环
      }else{
        submsg1 += (char)payload[1]; //温度
        submsg1 += (char)payload[2];
        subMSG1 = submsg1.toInt();
        int wdt = EEPROM.read(1); //读取温度校准数据
        subMSG1 = wd + wdt - subMSG1;
        wd = wd + wdt - subMSG1;
        EEPROM.write(1, subMSG1);
        if (EEPROM.commit()) {
          Serial.println("温度校准成功");
        } else {
          Serial.println("温度校准失败！");
        }
      }
    } else {
      Serial.println("接收到远程锁定命令(锁定程序未设定)");
    }
    callbackend:
    pubmassage();
    Serial.println("远程指令执行结束");
  }
}


void reconnect() {
  // Loop until we're reconnected
if (!client.connected() && currentMillis - lastfailedMQTTtime > MQTTwaitingtime) {
    // Create a random client ID
    if (client.connect(mqttid.c_str(), mqttname.c_str(), mqttpas.c_str(),pubtopic1, 2, 1, "d", 1)) { //（客户端ID，[用户名，密码]，[遗嘱消息主题，遗嘱消息QoS，遗嘱消息是否服务器保留，遗嘱消息内容]，[cleanSession]）
      // Once connected, publish an announcement...
      client.publish(pubtopic1, subtopic1.c_str());
      // ... and resubscribe
      /*subtopic2 = subtopic.c_str();
      client.unsubscribe(subtopic2);
      subtopic2 = subtopic1.c_str();
      client.unsubscribe (subtopic2);
      delay(100);*/
      subtopic2 = subtopic.c_str();
      client.subscribe(subtopic2, 1);
      MQTTwaitingtime = 5000;
      pubmassage();
    } else {
      switch (MQTTwaitingtime) { //根据前一次等待时间确定本次等待时间
        case 0 : MQTTwaitingtime = 5000;break;
        case 5000 : MQTTwaitingtime = 10000;  break;
        case 10000 : MQTTwaitingtime = 30000;  break;
        case 30000 : MQTTwaitingtime = 120000;  break;
        case 120000 : MQTTwaitingtime = 600000;  break;
        case 600000 : MQTTwaitingtime = 1800000;  break;
        case 1800000 : MQTTwaitingtime = 3600000;  break;
        default:
          MQTTwaitingtime = 3600000;  break;
      }
      lastfailedMQTTtime = millis();
    }
  }
}

void pubmassage() {
  String msg;
  msg +="硬件版本：";
  msg += yjbb;
  msg +="；固件版本：";
  msg += gjbb;
  msg +="；18B20：温度";
  msg += wd;
  msg +="°C;IP地址：";
  msg += myip;
  msg +="°C;IP地址：";
  msg +=lastmsgwatercontent;
  const char* pubmsg = msg.c_str();
  //      msg=硬件版本5+固件版本3+温度2+湿度2+亮度3
  client.publish(pubtopic1, pubmsg);
}

void readtemhum(){
  sensors.requestTemperatures();  // 发送命令获取温度
  wd = sensors.getTempCByIndex(0);
  lastreadtime = millis(); 
/*热敏电阻测温部分
  pinMode(13, OUTPUT); //设置GPIO13为输出
  digitalWrite(13,1);
  delay(100);
  int Rr,Aw;
  Aw = analogRead(A0);
  pinMode(13,INPUT); //设置GPIO16为输入（测温、测量度切换，高电位为温度，输入为亮度）
  float Awf=float(Aw);
  float Rrf=3376*330000/Awf-1080000;
  wd =1/( 1/298.15 - log(100000/Rrf)/3950)-273.15;
  if(lastwd != wd){
    if(pu == 1){
      pubmassage();
    }
  }

*/
}


void testwatercontent(){//花盆1.2.3.4：GPIO16.3.5.4,水位捡测：GPIO15,阀门/电机1.2.3.4:0.1.14.12，温度检测:GPIO13，18B20：GPIO2
  int Asd;
  if(w != 2){
    Asd = analogRead(A0);
    if(millis()-waterstarttime > 1000){//开始浇水一分钟后如果湿度读数没有明显变化，停止浇水，判断为停水或电磁阀失效
      if(Asd > Asdl-30){
        digitalWrite(hpl,0); //设置花盆检测GPIO状态（低电平关闭） 
        digitalWrite(w,0); //关闭浇水的阀门（低电平关闭） 
        w = 2;
        lastbadhptesttime = millis();
        switch(hpl){
          case 3: badhp3 =1 ;break;
          case 4: badhp4 =1 ;break;
          case 5: badhp5 =1 ;break;
          case 16: badhp16 =1 ;break;
          default : break;
        }
      }
    }
    if(Asd < 400){//浇水阀值400(暂定)，ADC读数小于400时对应的阀门/水泵关闭浇水
      digitalWrite(hpl,0); //设置花盆检测GPIO状态（低电平关闭） 
      digitalWrite(w,0); //关闭浇水的阀门（低电平关闭） 
      w = 2;
      if(lastbadhptesttime !=0){
        badhp3 = 0;
        badhp4 = 0;
        badhp5 = 0;
        badhp16 = 0;
        lastbadhptesttime = 0;
      }
    }
  }else{
    switch(hp){
      case 3: hp =5 ;break;
      case 4: hp =13;break;
      case 5: hp =4 ;break;
      case 13: hp =16 ;Asdl=0 ;break;
      case 16: hp =3 ;break;
      default : break;
    }
    if(hp == 13){//计算温度，并根据湿度确定是否浇水
      readtemhum();
      lastmsgwatercontent = msgwatercontent;
      msgwatercontent.clear();
      if(Asdl > 500 ){//浇水阀值500，ADC读数大于500时对应的阀门/水泵开启浇水
        waitingtime = 200;
        switch(hpl){//阀门：0,1,14,12
          case 3: w = 1 ; break;
          case 4: w = 12 ; break;
          case 5: w = 14 ; break;
          case 16: w = 0 ; break;
          default : break;
        }
        digitalWrite(hpl,1) ; //开启最缺水花盆的湿度检测
        digitalWrite(w,1) ; //开启对应阀门
        waterstarttime = millis();
        if(pu == 1){
          pubmassage();
        }
        delay(100);
      }else{
        if(lastbadhptesttime !=0 && millis() - lastbadhptesttime > 300000){
          badhp3 = 0;
          badhp4 = 0;
          badhp5 = 0;
          badhp16 = 0;
          lastbadhptesttime = 0;
        }
      }
      if(pu == 1){
        pubmassage();
      }
    }else{
      digitalWrite(hp, HIGH); //设置GPIO状态（高电平测量）
      delay(100);
      Asd = analogRead(A0);
      digitalWrite(hp, LOW); //设置GPIO状态（低电平关闭）
      if(Asd > 99){
        if(Asd>Asdl){
           switch(hp){
            case 3: if(badhp3 == 0){Asdl = Asd;hpl = hp;};break;
            case 4: if(badhp4 ==0){Asdl = Asd;hpl = hp;};break;
            case 5: if(badhp5 ==0){Asdl = Asd;hpl = hp;};break;
            case 16:if(badhp16 ==0){Asdl = Asd;hpl = hp;};break;
            default : break;
          }
        }
        msgwatercontent += Asd;
        msgwatercontent +="；";
      }
      waitingtime = 5000;
    }
  }
}
